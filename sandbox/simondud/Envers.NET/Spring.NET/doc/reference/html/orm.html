<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;21.&nbsp;Object Relational Mapping (ORM) data access</title><link rel="stylesheet" href="styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot_8103"><link rel="home" href="index.html" title="The Spring.NET Framework"><link rel="up" href="spring-middle-tier.html" title="Part&nbsp;II.&nbsp;Middle Tier Data Access"><link rel="prev" href="ado.html" title="Chapter&nbsp;20.&nbsp;Data access using ADO.NET"><link rel="next" href="spring-web.html" title="Part&nbsp;III.&nbsp;The Web"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="background-color:white;border:none;height:73px;border:1px solid black;"><a style="border:none;" href="http://www.springframework.net/" title="The Spring Framework"><img style="border:none;" src="images/xdev-spring_logo.jpg"></img></a><a style="border:none;" href="http://www.springsource.com/" title="SpringSource"><img style="border:none;position:absolute;padding-top:5px;right:42px;" src="images/S2-banner-rhs.png"></img></a></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="orm"></a>Chapter&nbsp;21.&nbsp;Object Relational Mapping (ORM) data access</h2></div></div></div>
  

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-introduction"></a>21.1.&nbsp;Introduction</h2></div></div></div>
    

    <p>The Spring Framework provides integration with <span class="emphasis"><em>NHibernate
    </em></span> in terms of resource management, DAO implementation support,
    and transaction strategies. For example for NHibernate, there is
    first-class support with lots of IoC convenience features, addressing many
    typical NHibernate integration issues. All of these support packages for
    O/R (Object Relational) mappers comply with Spring's generic transaction
    and DAO exception hierarchies. There are usually two integration styles:
    either using Spring's DAO 'templates' or coding DAOs against the 'plain'
    NHibernate APIs. In both cases, DAOs can be configured through Dependency
    Injection and participate in Spring's resource and transaction
    management.</p>

    <p>You can use Spring's support for NHibernate without needing to use
    Spring IoC or transaction management functionality. The NHibernate support
    classes can be used in typical 3rd party library style. However, usage
    inside a Spring IoC container does provide additional benefits in terms of
    ease of configuration and deployment; as such, most examples in this
    section show configuration inside a Spring container.</p>

    <p>Some of the benefits of using the Spring Framework to create your
    ORM DAOs include:</p>

    <div class="itemizedlist"><ul type="disc"><li>
        <p><span class="emphasis"><em>Ease of testing.</em></span> Spring's IoC approach
        makes it easy to swap the implementations and config locations of
        Hibernate <code class="literal">SessionFactory</code> instances, ADO.NET
        <code class="literal">DbProvider</code> instances, transaction managers, and
        mapper object implementations (if needed). This makes it much easier
        to isolate and test each piece of persistence-related code in
        isolation.</p>
      </li><li>
        <p><span class="emphasis"><em>Common data access exceptions.</em></span> Spring can
        wrap exceptions from your O/R mapping tool of choice, converting them
        from proprietary exceptions to a common runtime DataAccessException
        hierarchy. You can still trap and handle exceptions anywhere you need
        to. Remember that ADO.NET exceptions (including DB specific dialects)
        are also converted to the same hierarchy, meaning that you can perform
        some operations with ADO.NET within a consistent programming
        model.</p>
      </li><li>
        <p><span class="emphasis"><em>General resource management.</em></span> Spring
        application contexts can handle the location and configuration of
        Hibernate <code class="literal">ISessionFactory</code> instances, ADO.NET
        <code class="literal">DbProvider</code> instances and other related resources.
        This makes these values easy to manage and change. Spring offers
        efficient, easy and safe handling of persistence resources. For
        example: related code using NHibernate generally needs to use the same
        NHibernate <code class="literal">Session</code> for efficiency and proper
        transaction handling. Spring makes it easy to transparently create and
        bind a <code class="literal">Session</code> to the current thread, either by
        using an explicit 'template' wrapper class at the code level or by
        exposing a current <code class="literal">Session</code> through the Hibernate
        <code class="literal">SessionFactory</code> (for DAOs based on plain Hibernate
        1.2 API). Thus Spring solves many of the issues that repeatedly arise
        from typical NHibernate usage, for any transaction environment (local
        or distributed).</p>
      </li><li>
        <p><span class="emphasis"><em>Integrated transaction management.</em></span> Spring
        allows you to wrap your O/R mapping code with either a declarative,
        AOP style method interceptor, or an explicit 'template' wrapper class
        at the code level. In either case, transaction semantics are handled
        for you, and proper transaction handling (rollback, etc) in case of
        exceptions is taken care of. As discussed below, you also get the
        benefit of being able to use and swap various transaction managers,
        without your Hibernate/ADO.NET related code being affected: for
        example, between local transactions and distributed, with the same
        full services (such as declarative transactions) available in both
        scenarios. As an additional benefit, ADO.NET-related code can fully
        integrate transactionally with the code you use to do O/R mapping.
        This is useful for data access that's not suitable for O/R mapping
        which still needs to share common transactions with ORM
        operations.</p>
      </li></ul></div>

    <p>The NHibernate Northwind example in the Spring distribution shows a
    NHibernate implementation of a persistence-technology agnostic DAO
    interfaces. (In the upcoming RC1 release the SpringAir example will
    demonstrate an ADO.NET and NHibernate based implementation of technology
    agnostic DAO interfaces.) The NHibernate Northwind example serves as a
    working sample application that illustrates the use of NHibernate in a
    Spring web application. It also leverages declarative transaction
    demarcation with different transaction strategies.</p>

    <p>Both NHibernate 1.0 and NHibernate 1.2 are supported. Differences
    relate to the use of generics and new features such as contextual
    sessions. For information on the latter, refer to the section <a class="link" href="orm.html#orm-hibernate-straight" title="21.2.4.&nbsp;Implementing DAOs based on plain Hibernate 1.2/2.x API">Implementing DAOs based on the plain
    NHibernate API</a>. The NHibernate 1.0 support is in the assembly
    Spring.Data.NHibernate and the 1.2 support is in the assembly
    Spring.Data.NHibernate12</p>

    <p>At the moment the only ORM supported in NHibernate, but others can
    be integrated with Spring (in as much as makes sense) to offer the same
    value proposition.</p>
  </div>

  <div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-hibernate"></a>21.2.&nbsp;NHibernate</h2></div></div></div>
    

    <p>We will start with a coverage of <a class="ulink" href="http://www.hibernate.org/" target="_top">NHibernate</a> in a Spring
    environment, using it to demonstrate the approach that Spring takes
    towards integrating O/R mappers. This section will cover many issues in
    detail and show different variations of DAO implementations and
    transaction demarcations. Most of these patterns can be directly
    translated to all other supported O/R mapping tools.</p>

    <p>The following discussion focuses on Hibernate 1.0.4, the major
    differences with NHibernate 1.2 being the ability to participate in Spring
    transaction/session management via the normal NHibernate API instead of
    the 'template' approach. Spring supports both NHibernate 1.0 and
    NHibernate 1.2 via separate .dlls with the same internal namespace.</p>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-resource-mngmnt"></a>21.2.1.&nbsp;Resource management</h3></div></div></div>
      

      <p>Typical business applications are often cluttered with repetitive
      resource management code. Many projects try to invent their own
      solutions for this issue, sometimes sacrificing proper handling of
      failures for programming convenience. Spring advocates strikingly simple
      solutions for proper resource handling, namely IoC via templating; for
      example infrastructure classes with callback interfaces, or applying AOP
      interceptors. The infrastructure cares for proper resource handling, and
      for appropriate conversion of specific API exceptions to a common
      infrastructure exception hierarchy. Spring introduces a DAO exception
      hierarchy, applicable to any data access strategy. For direct ADO.NET,
      the <code class="literal">AdoTemplate</code> class mentioned in a previous section
      cares for connection handling, and for proper conversion of ADO.NET data
      access exceptions (not even singly rooted in .NET 1.1) to Spring's
      <code class="literal">DataAccessException</code> hierarchy, including translation
      of database-specific SQL error codes to meaningful exception classes. It
      supports both distributed and local transactions, via respective Spring
      transaction managers.</p>

      <p>Spring also offers Hibernate support, consisting of a
      <code class="literal">HibernateTemplate</code> analogous to
      <code class="literal">AdoTemplate</code>, a
      <code class="literal">HibernateInterceptor</code>, and a Hibernate transaction
      manager. The major goal is to allow for clear application layering, with
      any data access and transaction technology, and for loose coupling of
      application objects. No more business service dependencies on the data
      access or transaction strategy, no more hard-coded resource lookups, no
      more hard-to-replace singletons, no more custom service registries. One
      simple and consistent approach to wiring up application objects, keeping
      them as reusable as possible. All the individual data access features
      are usable on their own but integrate nicely with Spring's application
      context concept, providing XML-based configuration and cross-referencing
      of plain object instances that don't need to be Spring-aware. In a
      typical Spring application, many important objects are plain .NET
      objects: data access templates, data access objects (that use the
      templates), transaction managers, business services (that use the data
      access objects and transaction managers), ASP.NET web pages (that use
      the business services),and so on.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-tx-mgmt"></a>21.2.2.&nbsp;Transaction Management</h3></div></div></div>
      

      <p>While NHibernate offers an API for transaction management you will
      quite likely find the benefits of using Spring's generic transaction
      management features to be more compelling to use, typically for use of a
      declarative programming model for transaction demarcation and easily
      mixing ADO.NET and NHibernate operations within a single transaction.
      See the chapter on transaction management for more information on
      Spring's transaction management features. There are two choices for
      transaction management strategies, one based on the NHibernate API and
      the other the .NET 2.0 TransactionScope API.</p>

      <p>The first strategy is encapsulated in the class
      <code class="literal">Spring.Data.NHibernate.HibernateTransactionManager </code>in
      both the <code class="literal">Spring.Data.NHibernate </code>namespace. This
      strategy is preferred when you are using a single database. ADO.NET
      operations can also participate in the same transaction, either by using
      AdoTemplate or by retrieving the ADO.NET connection/transaction object
      pair stored in thread local storage when the transaction begins. Refer
      to the documentation of Spring's ADO.NET framework for more information
      on retrieving and using the connection/transaction pair without using
      AdoTemplate. You can use the HibernateTransactionManager and associated
      classes such as SessionFactory, HibernateTemplate directly as you would
      any third party API, however they are most commonly used through
      Spring's XML configuration file to gain the benefits of easy
      configuration for a particular runtime environment and as the basis for
      the configuration of a data access layer also configured using XML. An
      XML fragment showing the declaration of
      <code class="literal">HibernateTransactionManager</code> is shown below.</p>

      <pre class="programlisting">  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"transactionManager"</span>
        <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.HibernateTransactionManager, Spring.Data.NHibernate"</span><span style="color: #A31515">&gt;</span>

    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"DbProvider"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"DbProvider"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"SessionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"MySessionFactory"</span><span style="color: #A31515">/&gt;</span>

  <span style="color: #A31515">&lt;/object&gt;</span></pre>

      <p>The important property of
      <code class="literal">HibernateTransactionManager</code> are the references to the
      DbProvider and the Hibernate ISessionFactory. For more information on
      the DbProvider, refer to the chapter <a class="link" href="dbprovider.html" title="Chapter&nbsp;19.&nbsp;DbProvider">DbProvider</a> and the following section on
      SessionFactory set up.</p>

      <p>The second strategy is to use the class
      <code class="literal">Sping.Data.TxScopeTransactionManager</code> that uses .NET
      2.0 System.Transaction namespace and its corresponding TransactionScope
      API. This is preferred when you are using multiple transactional
      resources, such as multiple databases.</p>

      <p>Both strategies associate one Hibernate Session for the scope of
      the transaction (scope in the general demarcation sense, not
      System.Transaction sense). If there is no transaction then a new Session
      will be opened for each operation. The exception to this rule is when
      using the <code class="literal">OpenSessionInViewModule</code> in a web
      application in single session mode (see <a class="xref" href="orm.html#orm-hibernate-web" title="21.2.8.&nbsp;Web Session Management">Section&nbsp;21.2.8, &#8220;Web Session Management&#8221;</a>). In this case the session will be
      created on the start of the web request and closed on the end of the
      request. Note that the session's flush mode will be set to
      <code class="literal">FlushMode.NEVER</code> at the start of the request. If a
      non-readonly transaction is performed, then during the scope of that
      transaction processing the flush mode will be changed to AUTO, and then
      set back to NEVER at the end of the transaction scope so that any
      changes to objects associated with the session during rendering will not
      be persisted back to the database when the session is closed at the end
      of the web request.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-session-factory-setup"></a>21.2.3.&nbsp;<code class="literal">SessionFactory</code> set up in a Spring
      container</h3></div></div></div>
      

      <p>To avoid tying application objects to hard-coded resource lookups,
      Spring allows you to define resources like a
      <code class="literal">DbProvider</code> or a Hibernate
      <code class="literal">SessionFactory</code> as objects in an application context.
      Application objects that need to access resources just receive
      references to such pre-defined instances via object references (the DAO
      definition in the next section illustrates this). The following excerpt
      from an XML application context definition shows how to set up Spring's
      ADO.NET DbProvider and a Hibernate <code class="literal">SessionFactory</code> on
      top of it:</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;objects</span> <span style="color: #FF0000">xmlns</span>=<span style="color: #0000FF">"http://www.springframework.net"</span>
         <span style="color: #FF0000">xmlns:db</span>=<span style="color: #0000FF">"http://www.springframework.net/database"</span><span style="color: #A31515">&gt;</span>


  <i style="color: #008000">&lt;!-- Property placeholder configurer for database settings --&gt;</i>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Objects.Factory.Config.PropertyPlaceholderConfigurer, Spring.Core"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ConfigSections"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"databaseSettings"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>

  <i style="color: #008000">&lt;!-- Database and NHibernate Configuration --&gt;</i>

  <span style="color: #A31515">&lt;db:provider</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"DbProvider"</span>
                   <span style="color: #FF0000">provider</span>=<span style="color: #0000FF">"SqlServer-1.1"</span>
                   <span style="color: #FF0000">connectionString</span>=<span style="color: #0000FF">"Integrated Security=false; Data Source=(local);Integrated Security=true;Database=Northwin;User ID=springqa;Password=springqa;"</span><span style="color: #A31515">/&gt;</span>



  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"MySessionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.LocalSessionFactoryObject, Spring.Data.NHibernate"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"DbProvider"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"DbProvider"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"MappingAssemblies"</span><span style="color: #A31515">&gt;</span>
      <span style="color: #A31515">&lt;list&gt;</span>
        <span style="color: #A31515">&lt;value&gt;</span>Spring.Northwind.Dao.NHibernate<span style="color: #A31515">&lt;/value&gt;</span>
      <span style="color: #A31515">&lt;/list&gt;</span>
    <span style="color: #A31515">&lt;/property&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"HibernateProperties"</span><span style="color: #A31515">&gt;</span>
      <span style="color: #A31515">&lt;dictionary&gt;</span>

        <span style="color: #A31515">&lt;entry</span> <span style="color: #FF0000">key</span>=<span style="color: #0000FF">"hibernate.connection.provider"</span>
               <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"NHibernate.Connection.DriverConnectionProvider"</span><span style="color: #A31515">/&gt;</span>

        <span style="color: #A31515">&lt;entry</span> <span style="color: #FF0000">key</span>=<span style="color: #0000FF">"hibernate.dialect"</span>
               <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"NHibernate.Dialect.MsSql2000Dialect"</span><span style="color: #A31515">/&gt;</span>

        <span style="color: #A31515">&lt;entry</span> <span style="color: #FF0000">key</span>=<span style="color: #0000FF">"hibernate.connection.driver_class"</span>
               <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"NHibernate.Driver.SqlClientDriver"</span><span style="color: #A31515">/&gt;</span>

      <span style="color: #A31515">&lt;/dictionary&gt;</span>
    <span style="color: #A31515">&lt;/property&gt;</span>

  <span style="color: #A31515">&lt;/object&gt;</span>

<span style="color: #A31515">&lt;/objects&gt;</span></pre>

      <p>Many of the properties on
      <code class="literal">LocalSessionFactoryObject</code> are those you will commonly
      configure, for example the property <code class="literal">MappingAssemblies</code>
      specifies a list of assemblies to seach for hibernate mapping files. The
      property <code class="literal">HibernateProperies</code> are the familiar
      NHibernate properties used to set typical options such as dialect and
      driver class. The location of NHibernate mapping information can also be
      specified using Spring's <a class="link" href="resources.html" title="Chapter&nbsp;7.&nbsp;Resources">IResource
      abstraction</a> via the property <code class="literal">MappingResources</code>.
      The IResource abstraction supports opening an input stream from
      assemblies, file system, and http(s) based on a Uri syntax. You can also
      leverage the extensibility of IResource and thereby allow NHibernate to
      obtain its configuration information from locations such as a database
      or LDAP.For other properties you can configure them as you normal using
      the file <code class="literal">hibernate.cfg.xml</code> and refer to it via the
      property <code class="literal">ConfigFileNames</code>. This property is a string
      array so multiple configuration files are supported.</p>

      <p>There are other properties in
      <code class="literal">LocalSessionFactoryObject</code> that relate to the
      integration of Spring with NHibernate. The property
      <code class="literal">ExposeTransactionAwareSessionFactory</code> is discussed
      below and allows you to use Spring's declarative transaction demarcation
      functionality with the standard NHibernate API (as compared to using
      HibernateTemplate).</p>

      <p>The property <code class="literal">DbProvider</code> is used to infer two
      NHibernate configurations options.</p>

      <div class="itemizedlist"><ul type="disc"><li>
          <p>Infer the connection string, typically done via the hibernate
          property "hibernate.connection.connection_string".</p>
        </li><li>
          <p>Delegate to the <code class="literal">DbProvider</code> itself as the
          NHibernate connection provider instead of listing it via property
          hibernate.connection.provider via
          <code class="literal">HibernateProperties</code>.</p>
        </li></ul></div>

      <p>If you specify both the property hibernate.connection.provider and
      DbProvider (as shown above) the configuration of the property
      hibernate.connection.provider is used and a warning level message is
      logged. If you use Spring's <code class="literal">DbProvider</code> as the
      NHibernate connection provider then you can take advantage of
      <code class="literal">IDbProvider</code> implementations that will let you change
      the connection string at runtime such as <a class="link" href="dbprovider.html#dbprovider-usercredentials" title="19.5.1.&nbsp;UserCredentialsDbProvider">UserCredentialsDbProvider</a>
      and <a class="link" href="dbprovider.html#dbprovider-multidelegating" title="19.5.2.&nbsp;MultiDelegatingDbProvider">MultiDelegatingDbProvider</a>.</p>

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
        <p><a class="link" href="dbprovider.html#dbprovider-usercredentials" title="19.5.1.&nbsp;UserCredentialsDbProvider">UserCredentialsDbProvider</a>
        and <a class="link" href="dbprovider.html#dbprovider-multidelegating" title="19.5.2.&nbsp;MultiDelegatingDbProvider">MultiDelegatingDbProvider</a>
        only change the connection string at runtime based on values in thread
        local storage and do not clear out the Hibernate cache that is unique
        to each <code class="literal">ISessionFactory</code> instance. As such, they are
        only useful for selecting at runtime a single database instance.
        Cleaning up an existing session factory when switching to a new
        database is left to user code. Creating a new session factory per
        connection string (assuming the same mapping files can be used across
        all databases connections) is not currently supported. To support this
        functionality, you can subclass
        <code class="literal">LocalSessionFactoryObject</code> and override the method
        <code class="literal">ISessionFactory NewSessionFactory(Configuration
        config)</code> so that it returns an implementation of
        <code class="literal">ISessionFactory</code> that selects among multiple
        instances based on values in thread local storage, much like the
        implementation of <code class="literal">MultiDelegatingDbProvider</code>.</p>
      </td></tr></table></div>

      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d4e6681"></a>21.2.3.1.&nbsp;Using FluentNHibernate to configure mappings with
        LocalSessionFactoryObject</h4></div></div></div>
        

        <p>Direct support for configuration of NHibernate mapping files
        using FluentNHibernate will be included in a future release. Until
        then, to see how you can extend LocalSessionFactoryObject to suppport
        using FluentNHibernate follow the instructions on Benny Michielson's
        blog post <a class="link" href="http://www.bennymichielsen.be/post/2009/01/04/Using-Fluent-NHibernate-in-SpringNet.aspx" target="_top">here</a>.</p>
      </div>

      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-hibernate-bytecodeprovider"></a>21.2.3.2.&nbsp;Spring's IByteCodeProvider implementation</h4></div></div></div>
        

        <p>Introduced in Hibernate 2.1 is support for <a class="link" href="http://fabiomaulo.blogspot.com/2009/05/nhibernate-ioc-integration.html" target="_top">dependency
        injection of hibernate managed objects</a> via the
        <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IBytecodeProvider</span> extension point. As of Spring
        1.3 provides
        <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">Spring.Data.NHibernate.Bytecode.BytecodeProvider</span>
        as the default <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IBytecodeProvider</span> implementation
        when using <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">LocalSessionFactory</span> object to
        configure an <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">ISessionFactory</span>. To use a
        different <span xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" style="color: #2B91AF">IBytecodeProvider</span> configure it via
        the standard the Hibernate means, using App.confg or Web.config via
        the element <code class="literal">&lt;bytecode-provider type="..."/&gt;
        </code>inside the
        <code class="literal">&lt;hibernate-configuration&gt;</code> section or
        progammatically by setting
        <code class="literal">Environment.BytecodeProvider</code>.</p>
      </div>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-straight"></a>21.2.4.&nbsp;Implementing DAOs based on plain Hibernate 1.2/2.x API</h3></div></div></div>
      

      <p>Hibernate 1.2 introduced a feature called "contextual Sessions",
      where Hibernate itself manages one current <code class="literal">ISession</code>
      per transaction. This is roughly equivalent to Spring's synchronization
      of one Hibernate <code class="literal">Session</code> per transaction. A
      corresponding DAO implementation looks like as follows, based on the
      plain Hibernate API:</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> ProductDaoImpl implements IProductDao {

    <span style="color: #0000FF">private</span> SessionFactory sessionFactory;

    <span style="color: #0000FF">public</span> ISessionFactory SessionFactory
    {
        <span style="color: #0000FF">get</span> { <span style="color: #0000FF">return</span> sessionFactory; }
        <span style="color: #0000FF">set</span> { sessionFactory = <span style="color: #0000FF">value</span>; }
    }

    <span style="color: #0000FF">public</span> IList&lt;Product&gt; LoadProductsByCategory(String category) {
        <span style="color: #0000FF">return</span> SessionFactory.GetCurrentSession()
                .CreateQuery(<span style="color: #000000">"from test.Product product where product.category=?"</span>)
                .SetParameter(0, category)
                .List&lt;Product&gt;();
    }
}


<span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> HibernateCustomerDao : ICustomerDao {

  <span style="color: #0000FF">private</span> ISessionFactory sessionFactory;

  <span style="color: #0000FF">public</span> ISessionFactory SessionFactory
  {
      <span style="color: #0000FF">set</span> { sessionFactory = <span style="color: #0000FF">value</span>; }
  }

  <span style="color: #0000FF">public</span> Customer SaveOrUpdate(Customer customer)
  {
      sessionFactory.GetCurrentSession().SaveOrUpdate(customer);
      <span style="color: #0000FF">return</span> customer;
  }
}</pre>

      <p>The above DAO follows the Dependency Injection pattern: it fits
      nicely into a Spring IoC container, just like it would if coded against
      Spring's <code class="literal">HibernateTemplate</code>. Of course, such a DAO can
      also be set up in plain C# (for example, in unit tests): simply
      instantiate it and call <code class="methodname">SessionFactory</code> property
      with the desired factory reference. As a Spring object definition, it
      would look as follows:</p>

      <pre class="programlisting">
<span style="color: #A31515">&lt;objects&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"CustomerDao"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Northwind.Dao.NHibernate.HibernateCustomerDao, Spring.Northwind.Dao.NHibernate"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"sessionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"MySessionFactory"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>

<span style="color: #A31515">&lt;/objects&gt;</span></pre>

      <p>The SessionFactory configuration to support this programming model
      can be done two ways, both via configuration of Spring's
      LocalSessionFactoryObject. You can enable the use of Spring's
      implementation of the NHibernate extension interface,
      ICurrentSessionContext, by setting the property
      'ExposeTransactionAwareSessionFactory' to true on
      LocalSessionFactoryObject. This is just a short-cut for setting the
      NHibernate property current_session_context_class with the name of the
      implementation class to use.</p>

      <p>The first way is shown below</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"sessionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.LocalSessionFactoryObject, Spring.Data.NHibernate12"</span><span style="color: #A31515">&gt;</span>

  <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ExposeTransactionAwareSessionFactory"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"true"</span><span style="color: #A31515"> /&gt;</span>

   <i style="color: #008000">&lt;!-- other configuration settings omitted --&gt;</i>

<span style="color: #A31515">&lt;/object&gt;</span></pre>

      <p>Which is simply a shortcut for the following configuration</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"sessionFactory"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.LocalSessionFactoryObject, Spring.Data.NHibernate12"</span><span style="color: #A31515">&gt;</span>

   <i style="color: #008000">&lt;!-- other configuration settings omitted --&gt;</i>

   <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"HibernateProperties"</span><span style="color: #A31515">&gt;</span>
     <span style="color: #A31515">&lt;dictionary&gt;</span>

       <i style="color: #008000">&lt;!-- other dictionary entries omitted --&gt;</i>

       <span style="color: #A31515">&lt;entry</span> <span style="color: #FF0000">key</span>=<span style="color: #0000FF">"hibernate.current_session_context_class"</span>
              <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.SpringSessionContext, Spring.Data.NHibernate12"</span><span style="color: #A31515">/&gt;</span>

    <span style="color: #A31515">&lt;/dictionary&gt;</span>
   <span style="color: #A31515">&lt;/property&gt;</span>

<span style="color: #A31515">&lt;/object&gt;</span></pre>

      <p>The main advantage of this DAO style is that it depends on the
      Hibernate API only; no import of any Spring class is required. This is
      of course appealing from a non-invasiveness perspective, and will no
      doubt feel more natural to Hibernate developers.</p>

      <div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-hibernate-straight-ex"></a>21.2.4.1.&nbsp;Exception Translation</h4></div></div></div>
        

        <p>However, the DAO implemenation as shown throws plain
        <code class="literal">HibernateException</code> which means that callers can
        only treat exceptions as generally fatal - unless they want to depend
        on Hibernate's own exception hierarchy. Catching specific causes such
        as an optimistic locking failure is not possible without tying the
        caller to the implementation strategy. This trade off might be
        acceptable to applications that are strongly Hibernate-based and/or do
        not need any special exception treatment. As an alternative you can
        use Spring's exception translation advice to convert the NHibernate
        exception to Spring's DataAccessException hierarchy.</p>

        <p>Spring offers a solution allowing exception translation to be
        applied transparently through the <code class="literal">[Repository]</code>
        attribute:</p>

        <pre class="programlisting">[Repository]
<span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> HibernateCustomerDao : ICustomerDao {

  <i style="color: #008000">// class body here</i>

}</pre>

        <p>and register an exception translation post processor.</p>

        <pre class="programlisting">&lt;objects&gt;

  &lt;!-- configure session factory (omittied for brevity) --&gt;

  &lt;!-- Exception translation object post processor --&gt;
  &lt;object type="Spring.Dao.Attributes.PersistenceExceptionTranslationPostProcessor, Spring.Data"/&gt;

  &lt;!-- Same DAO configuration as before --&gt;
  &lt;object id="CustomerDao" type="Spring.Northwind.Dao.NHibernate.HibernateCustomerDao, Spring.Northwind.Dao.NHibernate"&gt;
    &lt;property name="sessionFactory" ref="MySessionFactory"/&gt;
  &lt;/object&gt;

&lt;/objects&gt;</pre>

        <p>The postprocessor will automatically look for all exception
        translators (implementations of the
        <code class="literal">IPersistenceExceptionTranslator</code> interface) and
        advise all object marked with the <code class="literal">[Repository]</code>
        attribute so that the discovered translators can intercept and apply
        the appropriate translation on the thrown exceptions. Spring's
        <code class="literal">LocalSessionFactory</code> object implements the
        <code class="literal">IPersistenceExceptionTranslator</code> interface and
        performs the same exception translation as was done when using
        <code class="literal">HibernateTemplate</code>.</p>

        <p>The <code class="literal">[Repository</code>] attribute is definedin the
        Spring.Data assembly, however it is used as a 'marker' attribute, and
        you can provide your own if you would like to avoid coupling your DAO
        implementation to a Spring attribute. This is done by setting
        <code class="literal">PersistenceExceptionTranslationPostProcessor's</code>
        property <code class="literal">RepositoryAttributeType</code> to your own
        attribute type.</p>

        <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top">
            <p>In summary: DAOs can be implemented based on the plain
            Hibernate 1.2/2.0 API, while still being able to participate in
            Spring-managed transactions and exception translation.</p>
          </td></tr></table></div>
      </div>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-declarative"></a>21.2.5.&nbsp;Declarative transaction demarcation</h3></div></div></div>
      

      <p>Alternatively, one can use Spring's declarative transaction
      support, which essentially enables you to replace explicit transaction
      demarcation API calls in your C# code with an AOP transaction
      interceptor configured in a Spring container. You can either externalize
      the transaction semantics (like propagation behavior and isolation level
      ) in a configuration file or use the Transaction attribute on the
      service method to set the transaction semantics.</p>

      <p>An example showing attribute driven transaction is shown
      below</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;objects&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"TransactionManager"</span>
        <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.HibernateTransactionManager, Spring.Data.NHibernate"</span><span style="color: #A31515">&gt;</span>

    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"DbProvider"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"DbProvider"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"SessionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"MySessionFactory"</span><span style="color: #A31515">/&gt;</span>

  <span style="color: #A31515">&lt;/object&gt;</span>

  <i style="color: #008000">&lt;!-- DAO definition not listed, see above for an example. --&gt;</i>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"FulfillmentService"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Northwind.Service.FulfillmentService, Spring.Northwind.Service"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"CustomerDao"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"CustomerDao"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"OrderDao"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"OrderDao"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ShippingService"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ShippingService"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>

  <i style="color: #008000">&lt;!-- Import 'standard xml' configuration for attribute driven declarative tx management --&gt;</i>
  <span style="color: #A31515">&lt;import</span> <span style="color: #FF0000">resource</span>=<span style="color: #0000FF">"DeclarativeServicesAttributeDriven.xml"</span><span style="color: #A31515">/&gt;</span>

<span style="color: #A31515">&lt;/objects&gt;</span></pre>

      <p>Note that with the new transaction namespace, you can replace the
      importing of DeclarativeServicesAttributeDriven.xml with the following
      single line, <code class="code">&lt;tx:attribute-driven/&gt;</code> that more clearly
      expresses the intent as compared to the contents of
      DeclarativeServicesAttributeDriven.xml.</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;objects</span> <span style="color: #FF0000">xmlns</span>=<span style="color: #0000FF">"http://www.springframework.net"</span>
	        <span style="color: #FF0000">xmlns:tx</span>=<span style="color: #0000FF">"http://www.springframework.net/schema/tx"</span><span style="color: #A31515">&gt;</span>


  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"transactionManager"</span>
        <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.HibernateTransactionManager, Spring.Data.NHibernate"</span><span style="color: #A31515">&gt;</span>

    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"DbProvider"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"DbProvider"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"SessionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"MySessionFactory"</span><span style="color: #A31515">/&gt;</span>

  <span style="color: #A31515">&lt;/object&gt;</span>

  <i style="color: #008000">&lt;!-- DAO definition not listed, see above for an example. --&gt;</i>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"FulfillmentService"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Northwind.Service.FulfillmentService, Spring.Northwind.Service"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"CustomerDao"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"CustomerDao"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"OrderDao"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"OrderDao"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ShippingService"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ShippingService"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>


  <span class="emphasis"><em>&lt;tx:attribute-driven/&gt;</em></span>


<span style="color: #A31515">&lt;/objects&gt;</span></pre>

      <p>The placement of the transaction attribute in the service layer
      method is shown below.</p>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> FulfillmentService : IFulfillmentService
{
  <i style="color: #008000">// fields and properties for dao object omitted, see above</i>


    [Transaction(ReadOnly=<span style="color: #0000FF">false</span>)]
    <span style="color: #0000FF">public</span> <span style="color: #0000FF">void</span> ProcessCustomer(<span style="color: #0000FF">string</span> customerId)
    {

            <i style="color: #008000">//Find all orders for customer</i>
            Customer customer = CustomerDao.FindById(customerId);

            <span style="color: #0000FF">foreach</span> (Order order <span style="color: #0000FF">in</span> customer.Orders)
            {
                <i style="color: #008000">//Validate Order</i>
                Validate(order);

                <i style="color: #008000">//Ship with external shipping service</i>
                ShippingService.ShipOrder(order);

                <i style="color: #008000">//Update shipping date</i>
                order.ShippedDate = DateTime.Now;

                <i style="color: #008000">//Update shipment date</i>
                OrderDao.SaveOrUpdate(order);

                <i style="color: #008000">//Other operations...Decrease product quantity... etc</i>
            }

    }
}</pre>

      <p>If you prefer to not use attribute to demarcate your transaction
      boundaries, you can import a configuration file with the following XML
      instead of using &lt;tx:attribute-driven/&gt;</p>

      <pre class="programlisting">  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"TxProxyConfigurationTemplate"</span> <span style="color: #FF0000">abstract</span>=<span style="color: #0000FF">"true"</span>
          <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Transaction.Interceptor.TransactionProxyFactoryObject, Spring.Data"</span><span style="color: #A31515">&gt;</span>

    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"PlatformTransactionManager"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"HibernateTransactionManager"</span><span style="color: #A31515">/&gt;</span>

    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"TransactionAttributes"</span><span style="color: #A31515">&gt;</span>
      <span style="color: #A31515">&lt;name-values&gt;</span>
        <i style="color: #008000">&lt;!-- Add common methods across your services here --&gt;</i>
        <span style="color: #A31515">&lt;add</span> <span style="color: #FF0000">key</span>=<span style="color: #0000FF">"Process*"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"PROPAGATION_REQUIRED"</span><span style="color: #A31515">/&gt;</span>
      <span style="color: #A31515">&lt;/name-values&gt;</span>
    <span style="color: #A31515">&lt;/property&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span></pre>

      <p>Refer to the documentation on Spring Transaction management for
      configuration of other features, such as rollback rules.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-programmatic"></a>21.2.6.&nbsp;Programmatic transaction demarcation</h3></div></div></div>
      

      <p>Transactions can be demarcated in a higher level of the
      application, on top of such lower-level data access services spanning
      any number of operations. There are no restrictions on the
      implementation of the surrounding business service here as well, it just
      needs a Spring <code class="literal">PlatformTransactionManager</code>. Again, the
      latter can come from anywhere, but preferably as an object reference via
      a <code class="methodname">TransactionManager</code> property - just like the
      <code class="literal">productDAO</code> should be set via a
      <code class="methodname">setProductDao(..)</code> method. The following
      snippets show a transaction manager and a business service definition in
      a Spring application context, and an example for a business method
      implementation.</p>

      <pre class="programlisting"><span style="color: #A31515">&lt;objects&gt;</span>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"TransactionManager"</span>
        <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.HibernateTransactionManager, Spring.Data.NHibernate"</span><span style="color: #A31515">&gt;</span>

    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"DbProvider"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"DbProvider"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"SessionFactory"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"MySessionFactory"</span><span style="color: #A31515">/&gt;</span>

  <span style="color: #A31515">&lt;/object&gt;</span>

  <i style="color: #008000">&lt;!-- DAO definition not listed, see above for an example. --&gt;</i>

  <span style="color: #A31515">&lt;object</span> <span style="color: #FF0000">id</span>=<span style="color: #0000FF">"FulfillmentService"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Northwind.Service.FulfillmentService, Spring.Northwind.Service"</span><span style="color: #A31515">&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"CustomerDao"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"CustomerDao"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"OrderDao"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"OrderDao"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"ShippingService"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"ShippingService"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;property</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"TransactionManager"</span> <span style="color: #FF0000">ref</span>=<span style="color: #0000FF">"TransactionManager"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/object&gt;</span>


<span style="color: #A31515">&lt;/objects&gt;</span></pre>

      <pre class="programlisting"><span style="color: #0000FF">public</span> <span style="color: #0000FF">class</span> FulfillmentService : IFulfillmentService

    <span style="color: #0000FF">private</span> TransactionTemplate transactionTemplate;

    <span style="color: #0000FF">private</span> IProductDao productDao;

    <span style="color: #0000FF">private</span> ICustomerDao customerDao;

    <span style="color: #0000FF">private</span> IOrderDao orderDao;

    <span style="color: #0000FF">private</span> IShippingService shippingService;


    <span style="color: #0000FF">public</span> TransactionManager TransactionManager
    {
       <span style="color: #0000FF">set</span> { transactionTemplate = <span style="color: #0000FF">new</span> TransactionTemplate(<span style="color: #0000FF">value</span>);
    }
    <span style="color: #0000FF">public</span> <span style="color: #0000FF">void</span> ProcessCustomer(<span style="color: #0000FF">string</span> customerId)
    {
      tt.Execute(<span style="color: #0000FF">delegate</span>(ITransactionStatus status) 
          {
            <i style="color: #008000">//Find all orders for customer</i>
            Customer customer = CustomerDao.FindById(customerId);
            <span style="color: #0000FF">foreach</span> (Order order <span style="color: #0000FF">in</span> customer.Orders)
            {
                <i style="color: #008000">//Validate Order</i>
                Validate(order);

                <i style="color: #008000">//Ship with external shipping service</i>
                ShippingService.ShipOrder(order);

                <i style="color: #008000">//Update shipping date</i>
                order.ShippedDate = DateTime.Now;

                <i style="color: #008000">//Update shipment date</i>
                OrderDao.SaveOrUpdate(order);

                <i style="color: #008000">//Other operations...Decrease product quantity... etc</i>
            }
            <span style="color: #0000FF">return</span> <span style="color: #0000FF">null</span>;
          });
    }
}</pre>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-strategies"></a>21.2.7.&nbsp;Transaction management strategies</h3></div></div></div>
      

      <p>Both <code class="literal">TransactionTemplate</code> and
      <code class="literal">TransactionInterceptor</code> (not yet seen explicitly in
      above configuration, TransactionProxyFactoryObject uses a
      TransactionInterceptor, you would have to specify it explicitly if you
      were using an ordinary ProxyFactoryObject.) delegate the actual
      transaction handling to a <code class="literal">PlatformTransactionManager</code>
      instance, which can be a <code class="literal">HibernateTransactionManager</code>
      (for a single Hibernate <code class="literal">SessionFactory</code>, using a
      <code class="literal">ThreadLocal</code> <code class="literal">Session</code> under the
      hood) or a <code class="literal">TxScopeTransactionManager</code> (delegating to
      MS-DTC for distributed transaction) for Hibernate applications. You
      could even use a custom <code class="literal">PlatformTransactionManager</code>
      implementation. So switching from native Hibernate transaction
      management to TxScopeTransactionManager, such as when facing distributed
      transaction requirements for certain deployments of your application, is
      just a matter of configuration. Simply replace the Hibernate transaction
      manager with Spring's TxScopeTransactionManager implementation. Both
      transaction demarcation and data access code will work without changes,
      as they just use the generic transaction management APIs.</p>

      <p>For distributed transactions across multiple Hibernate session
      factories, simply combine <code class="literal">TxScopeTransactionManager</code>
      as a transaction strategy with multiple
      <code class="literal">LocalSessionFactoryObject</code> definitions. Each of your
      DAOs then gets one specific <code class="literal">SessionFactory</code> reference
      passed into it's respective object property.</p>

      <pre class="programlisting">TO BE DONE
     </pre>

      <p><code class="literal">HibernateTransactionManager</code> can export the
      ADO.NET <code class="literal">Transaction</code> used by Hibernate to plain
      ADO.NET access code, for a specific <code class="literal">DbProvider</code>.
      (matching connection string). This allows for high-level transaction
      demarcation with mixed Hibernate/ADO.NET data access!</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-web"></a>21.2.8.&nbsp;Web Session Management</h3></div></div></div>
      

      <p>The open session in view pattern keeps the hibernate session open
      during page rendering so lazily loaded hibernate objects can be
      displayed. You configure its use by adding an additional custom HTTP
      module declaration as shown below</p>

      <pre class="programlisting">  <span style="color: #A31515">&lt;system.web&gt;</span>
    <span style="color: #A31515">&lt;httpModules&gt;</span>
      <span style="color: #A31515">&lt;add</span> <span style="color: #FF0000">name</span>=<span style="color: #0000FF">"OpenSessionInView"</span> <span style="color: #FF0000">type</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.Support.OpenSessionInViewModule, Spring.Data.NHibernate"</span><span style="color: #A31515">/&gt;</span>
    <span style="color: #A31515">&lt;/httpModules&gt;</span>

...

  <span style="color: #A31515">&lt;/system.web&gt;</span></pre>

      <p>You can configure which SessionFactory the OpenSessionInViewModule
      will use by setting 'global' application key-value pairs as shown below.
      (this will change in future releases)</p>

      <pre class="programlisting">  <span style="color: #A31515">&lt;appSettings&gt;</span>
    <span style="color: #A31515">&lt;add</span> <span style="color: #FF0000">key</span>=<span style="color: #0000FF">"Spring.Data.NHibernate.Support.OpenSessionInViewModule.SessionFactoryObjectName"</span> <span style="color: #FF0000">value</span>=<span style="color: #0000FF">"SessionFactory"</span><span style="color: #A31515">/&gt;</span>
  <span style="color: #A31515">&lt;/appSettings&gt;</span></pre>

      <p>The default behavior of the module is that a single session is
      currently used for the life of the request. Refer to the earlier section
      on Transaction Management in this chapter for more information on how
      sessions are managed in the OpenSessionInViewModule. You can also
      configure in the application setting the EntityInterceptorObjectName
      using the key
      <code class="literal">Spring.Data.NHibernate.Support.OpenSessionInViewModule.EntityInterceptorObjectName</code>
      and if SingleSession mode is used via the key
      <code class="literal">Spring.Data.NHibernate.Support.OpenSessionInViewModule.SingleSession</code>.
      If SingleSession is set to false, referred to as 'deferred close mode',
      then each transaction scope will use a new Session and kept open until
      the end of the web request. This has the drawback that the first level
      cache is not reused across transactions and that objects are required to
      be unique across all sessions. Problems can arise if the same object is
      associated with more than one hibernate session.</p>

      <div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/admons/important.png"></td><th align="left">Important</th></tr><tr><td align="left" valign="top">
        <p>By default, OSIV applies <code class="literal">FlushMode.NEVER</code> on
        every session it creates. This is because if OSIV flushed pending
        changes during "EndRequest" and an error occurs, all response has
        already been sent to the client. There would be no way of telling the
        client about the error.</p>

        <p>By default this means you MUST explicitly demarcate transaction
        boundaries around non-readonly statements when using OSIV. For
        configuring transactions see <a class="xref" href="orm.html#orm-hibernate-tx-declarative" title="21.2.5.&nbsp;Declarative transaction demarcation">Section&nbsp;21.2.5, &#8220;Declarative transaction demarcation&#8221;</a> or the
        <span class="command"><strong>Spring.Data.NHibernate.Northwind</strong></span> example
        application.</p>
      </td></tr></table></div>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-sessionscope"></a>21.2.9.&nbsp;Session Scope</h3></div></div></div>
      

      <p>The class Spring.Data.NHibernate.Support.SessionScope allows for
      you to use a single NHibernate session across multiple transactions. The
      usage is shown below</p>

      <pre class="programlisting"><span style="color: #0000FF">using</span> (<span style="color: #0000FF">new</span> SessionScope())
{
    ... <span style="color: #0000FF">do</span> multiple operations with a single session, possibly <span style="color: #0000FF">in</span> multiple transactions.
}</pre>

      <p>Refer to the API documentation for information on overloaded
      constructor. At the end of the using block the session is automatically
      closed. All transactions within the scope use the same session, if you
      are using Spring's HibernateTemplate or using Spring's implementation of
      NHibernate 1.2's ICurrentSessionContext interface. See other sections in
      this chapter for further information on those usage scenarios.</p>
    </div>

    <div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-integration-testing"></a>21.2.10.&nbsp;Integration Testing</h3></div></div></div>
      

      <p>When using <a class="link" href="testing.html" title="Chapter&nbsp;16.&nbsp;Testing">Spring's Integration Testing
      support</a>, you should make sure that the hibernate session is
      flushed so that the database is updated, as compared to just updating
      the hibernate session cache. You can implement a base class as shown
      below to help with the integration testing</p>

      <pre class="programlisting">public abstract class NHibernateIntegrationTests : AbstractTransactionalSpringContextTests
{
    private SessionFactory sessionFactory;

    public ISessionFactory SessionFactory
    {
        get { return sessionFactory; }
        set { sessionFactory = value; }
    }

    protected override void OnSetUpInTransaction()
    {
       base.OnSetUpInTransaction();
       Assert.IsNotNull(SessionFactory);
       SessionFactory.GetCurrentSession().FlushMode = FlushMode.Always;
       SessionFactory.GetCurrentSession().CacheMode = CacheMode.Ignore;
    }
}</pre>

      <p></p>
    </div>
  </div>
</div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ado.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="spring-web.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;20.&nbsp;Data access using ADO.NET&nbsp;</td><td width="20%" align="center"><span style="color:white;font-size:90%;"><a href="http://www.springsource.com/" title="SpringSource">Sponsored by SpringSource</a></span></td><td width="40%" align="right" valign="top">&nbsp;Part&nbsp;III.&nbsp;The Web</td></tr></table></div></body></html>